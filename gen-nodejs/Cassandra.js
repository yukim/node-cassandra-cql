//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args){
  this.auth_request = null
if( args != null ){  if (null != args.auth_request)
  this.auth_request = args.auth_request
}}
Cassandra_login_args.prototype = {}
Cassandra_login_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest()
        this.auth_request.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_args')
  if (null != this.auth_request) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1)
    this.auth_request.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_login_result = function(args){
  this.authnx = null
  this.authzx = null
if( args != null ){  if (null != args.authnx)
  this.authnx = args.authnx
  if (null != args.authzx)
  this.authzx = args.authzx
}}
Cassandra_login_result.prototype = {}
Cassandra_login_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException()
        this.authnx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException()
        this.authzx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_result')
  if (null != this.authnx) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1)
    this.authnx.write(output)
    output.writeFieldEnd()
  }
  if (null != this.authzx) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2)
    this.authzx.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_set_keyspace_args.prototype = {}
Cassandra_set_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_result = function(args){
  this.ire = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_set_keyspace_result.prototype = {}
Cassandra_set_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_args = function(args){
  this.key = null
  this.column_path = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_args.prototype = {}
Cassandra_get_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_result = function(args){
  this.success = null
  this.ire = null
  this.nfe = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_result.prototype = {}
Cassandra_get_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_slice_args.prototype = {}
Cassandra_get_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_slice_result.prototype = {}
Cassandra_get_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size88 = 0
          var rtmp3
          this.success = []
          var _etype91 = 0
          rtmp3 = input.readListBegin()
          _etype91 = rtmp3.etype
          _size88 = rtmp3.size
          for (var _i92 = 0; _i92 < _size88; ++_i92)
          {
            var elem93 = null
            elem93 = new ttypes.ColumnOrSuperColumn()
            elem93.read(input)
            this.success.push(elem93)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter94 in this.success)
        {
          if (this.success.hasOwnProperty(iter94))
          {
            iter94=this.success[iter94]
            iter94.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_count_args.prototype = {}
Cassandra_get_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_count_result.prototype = {}
Cassandra_get_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0)
    output.writeI32(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_slice_args.prototype = {}
Cassandra_multiget_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size95 = 0
          var rtmp3
          this.keys = []
          var _etype98 = 0
          rtmp3 = input.readListBegin()
          _etype98 = rtmp3.etype
          _size95 = rtmp3.size
          for (var _i99 = 0; _i99 < _size95; ++_i99)
          {
            var elem100 = null
            elem100 = input.readString()
            this.keys.push(elem100)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter101 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter101))
          {
            iter101=this.keys[iter101]
            output.writeString(iter101)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_slice_result.prototype = {}
Cassandra_multiget_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size102 = 0
          var rtmp3
          this.success = {}
          var _ktype103 = 0
          var _vtype104 = 0
          rtmp3 = input.readMapBegin()
          _ktype103= rtmp3.ktype
          _vtype104= rtmp3.vtype
          _size102= rtmp3.size
          for (var _i106 = 0; _i106 < _size102; ++_i106)
          {
            key107 = null
            val108 = null
            key107 = input.readString()
            {
              var _size109 = 0
              var rtmp3
              val108 = []
              var _etype112 = 0
              rtmp3 = input.readListBegin()
              _etype112 = rtmp3.etype
              _size109 = rtmp3.size
              for (var _i113 = 0; _i113 < _size109; ++_i113)
              {
                var elem114 = null
                elem114 = new ttypes.ColumnOrSuperColumn()
                elem114.read(input)
                val108.push(elem114)
              }
              input.readListEnd()
            }
            this.success[key107] = val108
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter115 in this.success)        {
          if (this.success.hasOwnProperty(kiter115))
          {
            var viter116 = this.success[kiter115]
            output.writeString(kiter115)
            {
              output.writeListBegin(Thrift.Type.STRUCT, viter116.length)
              {
                for(var iter117 in viter116)
                {
                  if (viter116.hasOwnProperty(iter117))
                  {
                    iter117=viter116[iter117]
                    iter117.write(output)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_count_args.prototype = {}
Cassandra_multiget_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size118 = 0
          var rtmp3
          this.keys = []
          var _etype121 = 0
          rtmp3 = input.readListBegin()
          _etype121 = rtmp3.etype
          _size118 = rtmp3.size
          for (var _i122 = 0; _i122 < _size118; ++_i122)
          {
            var elem123 = null
            elem123 = input.readString()
            this.keys.push(elem123)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter124 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter124))
          {
            iter124=this.keys[iter124]
            output.writeString(iter124)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_count_result.prototype = {}
Cassandra_multiget_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size125 = 0
          var rtmp3
          this.success = {}
          var _ktype126 = 0
          var _vtype127 = 0
          rtmp3 = input.readMapBegin()
          _ktype126= rtmp3.ktype
          _vtype127= rtmp3.vtype
          _size125= rtmp3.size
          for (var _i129 = 0; _i129 < _size125; ++_i129)
          {
            key130 = null
            val131 = null
            key130 = input.readString()
            val131 = input.readI32()
            this.success[key130] = val131
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success))
      {
        for(var kiter132 in this.success)        {
          if (this.success.hasOwnProperty(kiter132))
          {
            var viter133 = this.success[kiter132]
            output.writeString(kiter132)
            output.writeI32(viter133)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_args = function(args){
  this.column_parent = null
  this.predicate = null
  this.range = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.range)
  this.range = args.range
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_range_slices_args.prototype = {}
Cassandra_get_range_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange()
        this.range.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.range) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3)
    this.range.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_range_slices_result.prototype = {}
Cassandra_get_range_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size134 = 0
          var rtmp3
          this.success = []
          var _etype137 = 0
          rtmp3 = input.readListBegin()
          _etype137 = rtmp3.etype
          _size134 = rtmp3.size
          for (var _i138 = 0; _i138 < _size134; ++_i138)
          {
            var elem139 = null
            elem139 = new ttypes.KeySlice()
            elem139.read(input)
            this.success.push(elem139)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter140 in this.success)
        {
          if (this.success.hasOwnProperty(iter140))
          {
            iter140=this.success[iter140]
            iter140.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_args = function(args){
  this.column_parent = null
  this.index_clause = null
  this.column_predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.index_clause)
  this.index_clause = args.index_clause
  if (null != args.column_predicate)
  this.column_predicate = args.column_predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_indexed_slices_args.prototype = {}
Cassandra_get_indexed_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause()
        this.index_clause.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate()
        this.column_predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.index_clause) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2)
    this.index_clause.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column_predicate) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3)
    this.column_predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_indexed_slices_result.prototype = {}
Cassandra_get_indexed_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size141 = 0
          var rtmp3
          this.success = []
          var _etype144 = 0
          rtmp3 = input.readListBegin()
          _etype144 = rtmp3.etype
          _size141 = rtmp3.size
          for (var _i145 = 0; _i145 < _size141; ++_i145)
          {
            var elem146 = null
            elem146 = new ttypes.KeySlice()
            elem146.read(input)
            this.success.push(elem146)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter147 in this.success)
        {
          if (this.success.hasOwnProperty(iter147))
          {
            iter147=this.success[iter147]
            iter147.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_args = function(args){
  this.key = null
  this.column_parent = null
  this.column = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.column)
  this.column = args.column
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_insert_args.prototype = {}
Cassandra_insert_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_insert_result.prototype = {}
Cassandra_insert_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_add_args = function(args){
  this.key = null
  this.column_parent = null
  this.column = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.column)
  this.column = args.column
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_add_args.prototype = {}
Cassandra_add_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.CounterColumn()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_add_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_add_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_add_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_add_result.prototype = {}
Cassandra_add_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_add_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_add_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_args = function(args){
  this.key = null
  this.column_path = null
  this.timestamp = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.timestamp)
  this.timestamp = args.timestamp
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_remove_args.prototype = {}
Cassandra_remove_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_remove_result.prototype = {}
Cassandra_remove_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_counter_args = function(args){
  this.key = null
  this.path = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.path)
  this.path = args.path
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_remove_counter_args.prototype = {}
Cassandra_remove_counter_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.path = new ttypes.ColumnPath()
        this.path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_counter_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_counter_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.path) {
    output.writeFieldBegin('path', Thrift.Type.STRUCT, 2)
    this.path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_counter_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_remove_counter_result.prototype = {}
Cassandra_remove_counter_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_counter_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_counter_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_args = function(args){
  this.mutation_map = null
  this.consistency_level = 1
if( args != null ){  if (null != args.mutation_map)
  this.mutation_map = args.mutation_map
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_batch_mutate_args.prototype = {}
Cassandra_batch_mutate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.MAP) {
        {
          var _size148 = 0
          var rtmp3
          this.mutation_map = {}
          var _ktype149 = 0
          var _vtype150 = 0
          rtmp3 = input.readMapBegin()
          _ktype149= rtmp3.ktype
          _vtype150= rtmp3.vtype
          _size148= rtmp3.size
          for (var _i152 = 0; _i152 < _size148; ++_i152)
          {
            key153 = null
            val154 = null
            key153 = input.readString()
            {
              var _size155 = 0
              var rtmp3
              val154 = {}
              var _ktype156 = 0
              var _vtype157 = 0
              rtmp3 = input.readMapBegin()
              _ktype156= rtmp3.ktype
              _vtype157= rtmp3.vtype
              _size155= rtmp3.size
              for (var _i159 = 0; _i159 < _size155; ++_i159)
              {
                key160 = null
                val161 = null
                key160 = input.readString()
                {
                  var _size162 = 0
                  var rtmp3
                  val161 = []
                  var _etype165 = 0
                  rtmp3 = input.readListBegin()
                  _etype165 = rtmp3.etype
                  _size162 = rtmp3.size
                  for (var _i166 = 0; _i166 < _size162; ++_i166)
                  {
                    var elem167 = null
                    elem167 = new ttypes.Mutation()
                    elem167.read(input)
                    val161.push(elem167)
                  }
                  input.readListEnd()
                }
                val154[key160] = val161
              }
              input.readMapEnd()
            }
            this.mutation_map[key153] = val154
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_args')
  if (null != this.mutation_map) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map))
      {
        for(var kiter168 in this.mutation_map)        {
          if (this.mutation_map.hasOwnProperty(kiter168))
          {
            var viter169 = this.mutation_map[kiter168]
            output.writeString(kiter168)
            {
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter169))
              {
                for(var kiter170 in viter169)                {
                  if (viter169.hasOwnProperty(kiter170))
                  {
                    var viter171 = viter169[kiter170]
                    output.writeString(kiter170)
                    {
                      output.writeListBegin(Thrift.Type.STRUCT, viter171.length)
                      {
                        for(var iter172 in viter171)
                        {
                          if (viter171.hasOwnProperty(iter172))
                          {
                            iter172=viter171[iter172]
                            iter172.write(output)
                          }
                        }
                      }
                      output.writeListEnd()
                    }
                  }
                }
              }
              output.writeMapEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_batch_mutate_result.prototype = {}
Cassandra_batch_mutate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_args = function(args){
  this.cfname = null
if( args != null ){  if (null != args.cfname)
  this.cfname = args.cfname
}}
Cassandra_truncate_args.prototype = {}
Cassandra_truncate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_args')
  if (null != this.cfname) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1)
    output.writeString(this.cfname)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_result = function(args){
  this.ire = null
  this.ue = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
}}
Cassandra_truncate_result.prototype = {}
Cassandra_truncate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_args = function(args){
}
Cassandra_describe_schema_versions_args.prototype = {}
Cassandra_describe_schema_versions_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_schema_versions_result.prototype = {}
Cassandra_describe_schema_versions_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size173 = 0
          var rtmp3
          this.success = {}
          var _ktype174 = 0
          var _vtype175 = 0
          rtmp3 = input.readMapBegin()
          _ktype174= rtmp3.ktype
          _vtype175= rtmp3.vtype
          _size173= rtmp3.size
          for (var _i177 = 0; _i177 < _size173; ++_i177)
          {
            key178 = null
            val179 = null
            key178 = input.readString()
            {
              var _size180 = 0
              var rtmp3
              val179 = []
              var _etype183 = 0
              rtmp3 = input.readListBegin()
              _etype183 = rtmp3.etype
              _size180 = rtmp3.size
              for (var _i184 = 0; _i184 < _size180; ++_i184)
              {
                var elem185 = null
                elem185 = input.readString()
                val179.push(elem185)
              }
              input.readListEnd()
            }
            this.success[key178] = val179
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter186 in this.success)        {
          if (this.success.hasOwnProperty(kiter186))
          {
            var viter187 = this.success[kiter186]
            output.writeString(kiter186)
            {
              output.writeListBegin(Thrift.Type.STRING, viter187.length)
              {
                for(var iter188 in viter187)
                {
                  if (viter187.hasOwnProperty(iter188))
                  {
                    iter188=viter187[iter188]
                    output.writeString(iter188)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_args = function(args){
}
Cassandra_describe_keyspaces_args.prototype = {}
Cassandra_describe_keyspaces_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspaces_result.prototype = {}
Cassandra_describe_keyspaces_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size189 = 0
          var rtmp3
          this.success = []
          var _etype192 = 0
          rtmp3 = input.readListBegin()
          _etype192 = rtmp3.etype
          _size189 = rtmp3.size
          for (var _i193 = 0; _i193 < _size189; ++_i193)
          {
            var elem194 = null
            elem194 = new ttypes.KsDef()
            elem194.read(input)
            this.success.push(elem194)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter195 in this.success)
        {
          if (this.success.hasOwnProperty(iter195))
          {
            iter195=this.success[iter195]
            iter195.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_args = function(args){
}
Cassandra_describe_cluster_name_args.prototype = {}
Cassandra_describe_cluster_name_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_cluster_name_result.prototype = {}
Cassandra_describe_cluster_name_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_args = function(args){
}
Cassandra_describe_version_args.prototype = {}
Cassandra_describe_version_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_version_result.prototype = {}
Cassandra_describe_version_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_ring_args.prototype = {}
Cassandra_describe_ring_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_ring_result.prototype = {}
Cassandra_describe_ring_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size196 = 0
          var rtmp3
          this.success = []
          var _etype199 = 0
          rtmp3 = input.readListBegin()
          _etype199 = rtmp3.etype
          _size196 = rtmp3.size
          for (var _i200 = 0; _i200 < _size196; ++_i200)
          {
            var elem201 = null
            elem201 = new ttypes.TokenRange()
            elem201.read(input)
            this.success.push(elem201)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter202 in this.success)
        {
          if (this.success.hasOwnProperty(iter202))
          {
            iter202=this.success[iter202]
            iter202.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_args = function(args){
}
Cassandra_describe_partitioner_args.prototype = {}
Cassandra_describe_partitioner_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_partitioner_result.prototype = {}
Cassandra_describe_partitioner_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_args = function(args){
}
Cassandra_describe_snitch_args.prototype = {}
Cassandra_describe_snitch_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_snitch_result.prototype = {}
Cassandra_describe_snitch_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_keyspace_args.prototype = {}
Cassandra_describe_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_result = function(args){
  this.success = null
  this.nfe = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspace_result.prototype = {}
Cassandra_describe_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_args = function(args){
  this.cfName = null
  this.start_token = null
  this.end_token = null
  this.keys_per_split = null
if( args != null ){  if (null != args.cfName)
  this.cfName = args.cfName
  if (null != args.start_token)
  this.start_token = args.start_token
  if (null != args.end_token)
  this.end_token = args.end_token
  if (null != args.keys_per_split)
  this.keys_per_split = args.keys_per_split
}}
Cassandra_describe_splits_args.prototype = {}
Cassandra_describe_splits_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_args')
  if (null != this.cfName) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1)
    output.writeString(this.cfName)
    output.writeFieldEnd()
  }
  if (null != this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2)
    output.writeString(this.start_token)
    output.writeFieldEnd()
  }
  if (null != this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3)
    output.writeString(this.end_token)
    output.writeFieldEnd()
  }
  if (null != this.keys_per_split) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4)
    output.writeI32(this.keys_per_split)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_splits_result.prototype = {}
Cassandra_describe_splits_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size203 = 0
          var rtmp3
          this.success = []
          var _etype206 = 0
          rtmp3 = input.readListBegin()
          _etype206 = rtmp3.etype
          _size203 = rtmp3.size
          for (var _i207 = 0; _i207 < _size203; ++_i207)
          {
            var elem208 = null
            elem208 = input.readString()
            this.success.push(elem208)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRING, this.success.length)
      {
        for(var iter209 in this.success)
        {
          if (this.success.hasOwnProperty(iter209))
          {
            iter209=this.success[iter209]
            output.writeString(iter209)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_add_column_family_args.prototype = {}
Cassandra_system_add_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_add_column_family_result.prototype = {}
Cassandra_system_add_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_args = function(args){
  this.column_family = null
if( args != null ){  if (null != args.column_family)
  this.column_family = args.column_family
}}
Cassandra_system_drop_column_family_args.prototype = {}
Cassandra_system_drop_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_args')
  if (null != this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1)
    output.writeString(this.column_family)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_drop_column_family_result.prototype = {}
Cassandra_system_drop_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_add_keyspace_args.prototype = {}
Cassandra_system_add_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_add_keyspace_result.prototype = {}
Cassandra_system_add_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_system_drop_keyspace_args.prototype = {}
Cassandra_system_drop_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_drop_keyspace_result.prototype = {}
Cassandra_system_drop_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_update_keyspace_args.prototype = {}
Cassandra_system_update_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_update_keyspace_result.prototype = {}
Cassandra_system_update_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_update_column_family_args.prototype = {}
Cassandra_system_update_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_update_column_family_result.prototype = {}
Cassandra_system_update_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_execute_cql_query_args = function(args){
  this.query = null
  this.compression = null
if( args != null ){  if (null != args.query)
  this.query = args.query
  if (null != args.compression)
  this.compression = args.compression
}}
Cassandra_execute_cql_query_args.prototype = {}
Cassandra_execute_cql_query_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_execute_cql_query_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_execute_cql_query_args')
  if (null != this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1)
    output.writeString(this.query)
    output.writeFieldEnd()
  }
  if (null != this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2)
    output.writeI32(this.compression)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_execute_cql_query_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_execute_cql_query_result.prototype = {}
Cassandra_execute_cql_query_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_execute_cql_query_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_execute_cql_query_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {}
}
CassandraClient.prototype = {}
CassandraClient.prototype.login = function(auth_request,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_login(auth_request)
}

CassandraClient.prototype.send_login = function(auth_request){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_login_args()
  args.auth_request = auth_request
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_login = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_login_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.authnx) {
    return callback(result.authnx);
  }
  if (null != result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
}
CassandraClient.prototype.set_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_set_keyspace(keyspace)
}

CassandraClient.prototype.send_set_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_set_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  callback(null)
}
CassandraClient.prototype.get = function(key,column_path,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get(key, column_path, consistency_level)
}

CassandraClient.prototype.send_get = function(key,column_path,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_args()
  args.key = key
  args.column_path = column_path
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get failed: unknown result");
}
CassandraClient.prototype.get_slice = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_slice(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_slice = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_slice_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_slice failed: unknown result");
}
CassandraClient.prototype.get_count = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_count(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_count = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_count_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_count failed: unknown result");
}
CassandraClient.prototype.multiget_slice = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_slice(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_slice = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_slice_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_slice failed: unknown result");
}
CassandraClient.prototype.multiget_count = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_count(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_count = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_count_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_count failed: unknown result");
}
CassandraClient.prototype.get_range_slices = function(column_parent,predicate,range,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_range_slices(column_parent, predicate, range, consistency_level)
}

CassandraClient.prototype.send_get_range_slices = function(column_parent,predicate,range,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_range_slices_args()
  args.column_parent = column_parent
  args.predicate = predicate
  args.range = range
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_range_slices failed: unknown result");
}
CassandraClient.prototype.get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level)
}

CassandraClient.prototype.send_get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_indexed_slices_args()
  args.column_parent = column_parent
  args.index_clause = index_clause
  args.column_predicate = column_predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_indexed_slices failed: unknown result");
}
CassandraClient.prototype.insert = function(key,column_parent,column,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_insert(key, column_parent, column, consistency_level)
}

CassandraClient.prototype.send_insert = function(key,column_parent,column,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_insert_args()
  args.key = key
  args.column_parent = column_parent
  args.column = column
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_insert_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.add = function(key,column_parent,column,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_add(key, column_parent, column, consistency_level)
}

CassandraClient.prototype.send_add = function(key,column_parent,column,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('add', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_add_args()
  args.key = key
  args.column_parent = column_parent
  args.column = column
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_add = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_add_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.remove = function(key,column_path,timestamp,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_remove(key, column_path, timestamp, consistency_level)
}

CassandraClient.prototype.send_remove = function(key,column_path,timestamp,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_remove_args()
  args.key = key
  args.column_path = column_path
  args.timestamp = timestamp
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_remove_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.remove_counter = function(key,path,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_remove_counter(key, path, consistency_level)
}

CassandraClient.prototype.send_remove_counter = function(key,path,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove_counter', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_remove_counter_args()
  args.key = key
  args.path = path
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_remove_counter = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_remove_counter_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.batch_mutate = function(mutation_map,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_batch_mutate(mutation_map, consistency_level)
}

CassandraClient.prototype.send_batch_mutate = function(mutation_map,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_batch_mutate_args()
  args.mutation_map = mutation_map
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.truncate = function(cfname,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_truncate(cfname)
}

CassandraClient.prototype.send_truncate = function(cfname){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_truncate_args()
  args.cfname = cfname
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_truncate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  callback(null)
}
CassandraClient.prototype.describe_schema_versions = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_schema_versions()
}

CassandraClient.prototype.send_describe_schema_versions = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_schema_versions_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_schema_versions failed: unknown result");
}
CassandraClient.prototype.describe_keyspaces = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspaces()
}

CassandraClient.prototype.send_describe_keyspaces = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspaces_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspaces failed: unknown result");
}
CassandraClient.prototype.describe_cluster_name = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_cluster_name()
}

CassandraClient.prototype.send_describe_cluster_name = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_cluster_name_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_cluster_name failed: unknown result");
}
CassandraClient.prototype.describe_version = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_version()
}

CassandraClient.prototype.send_describe_version = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_version_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_version_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_version failed: unknown result");
}
CassandraClient.prototype.describe_ring = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_ring(keyspace)
}

CassandraClient.prototype.send_describe_ring = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_ring_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_ring failed: unknown result");
}
CassandraClient.prototype.describe_partitioner = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_partitioner()
}

CassandraClient.prototype.send_describe_partitioner = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_partitioner_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_partitioner failed: unknown result");
}
CassandraClient.prototype.describe_snitch = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_snitch()
}

CassandraClient.prototype.send_describe_snitch = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_snitch_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_snitch failed: unknown result");
}
CassandraClient.prototype.describe_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspace(keyspace)
}

CassandraClient.prototype.send_describe_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspace failed: unknown result");
}
CassandraClient.prototype.describe_splits = function(cfName,start_token,end_token,keys_per_split,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_splits(cfName, start_token, end_token, keys_per_split)
}

CassandraClient.prototype.send_describe_splits = function(cfName,start_token,end_token,keys_per_split){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_splits_args()
  args.cfName = cfName
  args.start_token = start_token
  args.end_token = end_token
  args.keys_per_split = keys_per_split
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_splits failed: unknown result");
}
CassandraClient.prototype.system_add_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_column_family(cf_def)
}

CassandraClient.prototype.send_system_add_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_column_family failed: unknown result");
}
CassandraClient.prototype.system_drop_column_family = function(column_family,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_column_family(column_family)
}

CassandraClient.prototype.send_system_drop_column_family = function(column_family){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_column_family_args()
  args.column_family = column_family
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_column_family failed: unknown result");
}
CassandraClient.prototype.system_add_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_keyspace(ks_def)
}

CassandraClient.prototype.send_system_add_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_keyspace failed: unknown result");
}
CassandraClient.prototype.system_drop_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_keyspace(keyspace)
}

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_keyspace(ks_def)
}

CassandraClient.prototype.send_system_update_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_column_family(cf_def)
}

CassandraClient.prototype.send_system_update_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_column_family failed: unknown result");
}
CassandraClient.prototype.execute_cql_query = function(query,compression,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_execute_cql_query(query, compression)
}

CassandraClient.prototype.send_execute_cql_query = function(query,compression){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql_query', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_execute_cql_query_args()
  args.query = query
  args.compression = compression
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_execute_cql_query = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_execute_cql_query_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("execute_cql_query failed: unknown result");
}
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin()
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output)
  } else {
    input.skip(Thrift.Type.STRUCT)
    input.readMessageEnd()
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname)
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid)
    x.write(output)
    output.writeMessageEnd()
    output.flush()
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_login_result()
  this._handler.login(args.auth_request, function(success) {
    result.success = success
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_set_keyspace_result()
  this._handler.set_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_result()
  this._handler.get(args.key, args.column_path, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_slice_result()
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_count_result()
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_slice_result()
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_count_result()
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_range_slices_result()
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_indexed_slices_result()
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_insert_result()
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_add = function(seqid, input, output) {
  var args = new Cassandra_add_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_add_result()
  this._handler.add(args.key, args.column_parent, args.column, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("add", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_remove_result()
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_remove_counter = function(seqid, input, output) {
  var args = new Cassandra_remove_counter_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_remove_counter_result()
  this._handler.remove_counter(args.key, args.path, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("remove_counter", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_batch_mutate_result()
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_truncate_result()
  this._handler.truncate(args.cfname, function(success) {
    result.success = success
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_schema_versions_result()
  this._handler.describe_schema_versions(function(success) {
    result.success = success
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspaces_result()
  this._handler.describe_keyspaces(function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_cluster_name_result()
  this._handler.describe_cluster_name(function(success) {
    result.success = success
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_version_result()
  this._handler.describe_version(function(success) {
    result.success = success
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_ring_result()
  this._handler.describe_ring(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_partitioner_result()
  this._handler.describe_partitioner(function(success) {
    result.success = success
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_snitch_result()
  this._handler.describe_snitch(function(success) {
    result.success = success
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspace_result()
  this._handler.describe_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_splits_result()
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function(success) {
    result.success = success
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_column_family_result()
  this._handler.system_add_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_column_family_result()
  this._handler.system_drop_column_family(args.column_family, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_keyspace_result()
  this._handler.system_add_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_keyspace_result()
  this._handler.system_drop_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_keyspace_result()
  this._handler.system_update_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_column_family_result()
  this._handler.system_update_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_execute_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql_query_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_execute_cql_query_result()
  this._handler.execute_cql_query(args.query, args.compression, function(success) {
    result.success = success
    output.writeMessageBegin("execute_cql_query", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

