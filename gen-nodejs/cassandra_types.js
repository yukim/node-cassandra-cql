//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;
var ttypes = module.exports = {};
ttypes.ConsistencyLevel = { 
'ONE' : 1
,'QUORUM' : 2
,'LOCAL_QUORUM' : 3
,'EACH_QUORUM' : 4
,'ALL' : 5
,'ANY' : 6
,'TWO' : 7
,'THREE' : 8
}
ttypes.IndexOperator = { 
'EQ' : 0
,'GTE' : 1
,'GT' : 2
,'LTE' : 3
,'LT' : 4
}
ttypes.IndexType = { 
'KEYS' : 0
}
ttypes.Compression = { 
'GZIP' : 1
,'NONE' : 2
}
ttypes.CqlResultType = { 
'ROWS' : 1
,'VOID' : 2
,'INT' : 3
}
ttypes.VERSION = '20.1.0'
var Column = module.exports.Column = function(args){
  this.name = null
  this.value = null
  this.timestamp = null
  this.ttl = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.value)
  this.value = args.value
  if (null != args.timestamp)
  this.timestamp = args.timestamp
  if (null != args.ttl)
  this.ttl = args.ttl
}}
Column.prototype = {}
Column.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.ttl = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Column.prototype.write = function(output){ 
  output.writeStructBegin('Column')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.value) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 2)
    output.writeString(this.value)
    output.writeFieldEnd()
  }
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  if (null != this.ttl) {
    output.writeFieldBegin('ttl', Thrift.Type.I32, 4)
    output.writeI32(this.ttl)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var SuperColumn = module.exports.SuperColumn = function(args){
  this.name = null
  this.columns = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.columns)
  this.columns = args.columns
}}
SuperColumn.prototype = {}
SuperColumn.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size0 = 0
          var rtmp3
          this.columns = []
          var _etype3 = 0
          rtmp3 = input.readListBegin()
          _etype3 = rtmp3.etype
          _size0 = rtmp3.size
          for (var _i4 = 0; _i4 < _size0; ++_i4)
          {
            var elem5 = null
            elem5 = new ttypes.Column()
            elem5.read(input)
            this.columns.push(elem5)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

SuperColumn.prototype.write = function(output){ 
  output.writeStructBegin('SuperColumn')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.columns) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length)
      {
        for(var iter6 in this.columns)
        {
          if (this.columns.hasOwnProperty(iter6))
          {
            iter6=this.columns[iter6]
            iter6.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CounterColumn = module.exports.CounterColumn = function(args){
  this.name = null
  this.value = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.value)
  this.value = args.value
}}
CounterColumn.prototype = {}
CounterColumn.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I64) {
        this.value = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

CounterColumn.prototype.write = function(output){ 
  output.writeStructBegin('CounterColumn')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.value) {
    output.writeFieldBegin('value', Thrift.Type.I64, 2)
    output.writeI64(this.value)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CounterSuperColumn = module.exports.CounterSuperColumn = function(args){
  this.name = null
  this.columns = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.columns)
  this.columns = args.columns
}}
CounterSuperColumn.prototype = {}
CounterSuperColumn.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size7 = 0
          var rtmp3
          this.columns = []
          var _etype10 = 0
          rtmp3 = input.readListBegin()
          _etype10 = rtmp3.etype
          _size7 = rtmp3.size
          for (var _i11 = 0; _i11 < _size7; ++_i11)
          {
            var elem12 = null
            elem12 = new ttypes.CounterColumn()
            elem12.read(input)
            this.columns.push(elem12)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

CounterSuperColumn.prototype.write = function(output){ 
  output.writeStructBegin('CounterSuperColumn')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.columns) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length)
      {
        for(var iter13 in this.columns)
        {
          if (this.columns.hasOwnProperty(iter13))
          {
            iter13=this.columns[iter13]
            iter13.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var ColumnOrSuperColumn = module.exports.ColumnOrSuperColumn = function(args){
  this.column = null
  this.super_column = null
  this.counter_column = null
  this.counter_super_column = null
if( args != null ){  if (null != args.column)
  this.column = args.column
  if (null != args.super_column)
  this.super_column = args.super_column
  if (null != args.counter_column)
  this.counter_column = args.counter_column
  if (null != args.counter_super_column)
  this.counter_super_column = args.counter_super_column
}}
ColumnOrSuperColumn.prototype = {}
ColumnOrSuperColumn.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.super_column = new ttypes.SuperColumn()
        this.super_column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.counter_column = new ttypes.CounterColumn()
        this.counter_column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.counter_super_column = new ttypes.CounterSuperColumn()
        this.counter_super_column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

ColumnOrSuperColumn.prototype.write = function(output){ 
  output.writeStructBegin('ColumnOrSuperColumn')
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 1)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.super_column) {
    output.writeFieldBegin('super_column', Thrift.Type.STRUCT, 2)
    this.super_column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.counter_column) {
    output.writeFieldBegin('counter_column', Thrift.Type.STRUCT, 3)
    this.counter_column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.counter_super_column) {
    output.writeFieldBegin('counter_super_column', Thrift.Type.STRUCT, 4)
    this.counter_super_column.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var NotFoundException = module.exports.NotFoundException = function(args){
  Thrift.TException.call(this, "NotFoundException")
  this.name = "NotFoundException"
}
Thrift.inherits(NotFoundException, Thrift.TException)
NotFoundException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

NotFoundException.prototype.write = function(output){ 
  output.writeStructBegin('NotFoundException')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var InvalidRequestException = module.exports.InvalidRequestException = function(args){
  Thrift.TException.call(this, "InvalidRequestException")
  this.name = "InvalidRequestException"
  this.why = null
if( args != null ){  if (null != args.why)
  this.why = args.why
}}
Thrift.inherits(InvalidRequestException, Thrift.TException)
InvalidRequestException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.why = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

InvalidRequestException.prototype.write = function(output){ 
  output.writeStructBegin('InvalidRequestException')
  if (null != this.why) {
    output.writeFieldBegin('why', Thrift.Type.STRING, 1)
    output.writeString(this.why)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var UnavailableException = module.exports.UnavailableException = function(args){
  Thrift.TException.call(this, "UnavailableException")
  this.name = "UnavailableException"
}
Thrift.inherits(UnavailableException, Thrift.TException)
UnavailableException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

UnavailableException.prototype.write = function(output){ 
  output.writeStructBegin('UnavailableException')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var TimedOutException = module.exports.TimedOutException = function(args){
  Thrift.TException.call(this, "TimedOutException")
  this.name = "TimedOutException"
}
Thrift.inherits(TimedOutException, Thrift.TException)
TimedOutException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

TimedOutException.prototype.write = function(output){ 
  output.writeStructBegin('TimedOutException')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var AuthenticationException = module.exports.AuthenticationException = function(args){
  Thrift.TException.call(this, "AuthenticationException")
  this.name = "AuthenticationException"
  this.why = null
if( args != null ){  if (null != args.why)
  this.why = args.why
}}
Thrift.inherits(AuthenticationException, Thrift.TException)
AuthenticationException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.why = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

AuthenticationException.prototype.write = function(output){ 
  output.writeStructBegin('AuthenticationException')
  if (null != this.why) {
    output.writeFieldBegin('why', Thrift.Type.STRING, 1)
    output.writeString(this.why)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var AuthorizationException = module.exports.AuthorizationException = function(args){
  Thrift.TException.call(this, "AuthorizationException")
  this.name = "AuthorizationException"
  this.why = null
if( args != null ){  if (null != args.why)
  this.why = args.why
}}
Thrift.inherits(AuthorizationException, Thrift.TException)
AuthorizationException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.why = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

AuthorizationException.prototype.write = function(output){ 
  output.writeStructBegin('AuthorizationException')
  if (null != this.why) {
    output.writeFieldBegin('why', Thrift.Type.STRING, 1)
    output.writeString(this.why)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var SchemaDisagreementException = module.exports.SchemaDisagreementException = function(args){
  Thrift.TException.call(this, "SchemaDisagreementException")
  this.name = "SchemaDisagreementException"
}
Thrift.inherits(SchemaDisagreementException, Thrift.TException)
SchemaDisagreementException.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

SchemaDisagreementException.prototype.write = function(output){ 
  output.writeStructBegin('SchemaDisagreementException')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var ColumnParent = module.exports.ColumnParent = function(args){
  this.column_family = null
  this.super_column = null
if( args != null ){  if (null != args.column_family)
  this.column_family = args.column_family
  if (null != args.super_column)
  this.super_column = args.super_column
}}
ColumnParent.prototype = {}
ColumnParent.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRING) {
        this.super_column = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

ColumnParent.prototype.write = function(output){ 
  output.writeStructBegin('ColumnParent')
  if (null != this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 3)
    output.writeString(this.column_family)
    output.writeFieldEnd()
  }
  if (null != this.super_column) {
    output.writeFieldBegin('super_column', Thrift.Type.STRING, 4)
    output.writeString(this.super_column)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var ColumnPath = module.exports.ColumnPath = function(args){
  this.column_family = null
  this.super_column = null
  this.column = null
if( args != null ){  if (null != args.column_family)
  this.column_family = args.column_family
  if (null != args.super_column)
  this.super_column = args.super_column
  if (null != args.column)
  this.column = args.column
}}
ColumnPath.prototype = {}
ColumnPath.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRING) {
        this.super_column = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 5:      if (ftype == Thrift.Type.STRING) {
        this.column = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

ColumnPath.prototype.write = function(output){ 
  output.writeStructBegin('ColumnPath')
  if (null != this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 3)
    output.writeString(this.column_family)
    output.writeFieldEnd()
  }
  if (null != this.super_column) {
    output.writeFieldBegin('super_column', Thrift.Type.STRING, 4)
    output.writeString(this.super_column)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRING, 5)
    output.writeString(this.column)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var SliceRange = module.exports.SliceRange = function(args){
  this.start = null
  this.finish = null
  this.reversed = false
  this.count = 100
if( args != null ){  if (null != args.start)
  this.start = args.start
  if (null != args.finish)
  this.finish = args.finish
  if (null != args.reversed)
  this.reversed = args.reversed
  if (null != args.count)
  this.count = args.count
}}
SliceRange.prototype = {}
SliceRange.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.start = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.finish = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.BOOL) {
        this.reversed = input.readBool()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

SliceRange.prototype.write = function(output){ 
  output.writeStructBegin('SliceRange')
  if (null != this.start) {
    output.writeFieldBegin('start', Thrift.Type.STRING, 1)
    output.writeString(this.start)
    output.writeFieldEnd()
  }
  if (null != this.finish) {
    output.writeFieldBegin('finish', Thrift.Type.STRING, 2)
    output.writeString(this.finish)
    output.writeFieldEnd()
  }
  if (null != this.reversed) {
    output.writeFieldBegin('reversed', Thrift.Type.BOOL, 3)
    output.writeBool(this.reversed)
    output.writeFieldEnd()
  }
  if (null != this.count) {
    output.writeFieldBegin('count', Thrift.Type.I32, 4)
    output.writeI32(this.count)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var SlicePredicate = module.exports.SlicePredicate = function(args){
  this.column_names = null
  this.slice_range = null
if( args != null ){  if (null != args.column_names)
  this.column_names = args.column_names
  if (null != args.slice_range)
  this.slice_range = args.slice_range
}}
SlicePredicate.prototype = {}
SlicePredicate.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size14 = 0
          var rtmp3
          this.column_names = []
          var _etype17 = 0
          rtmp3 = input.readListBegin()
          _etype17 = rtmp3.etype
          _size14 = rtmp3.size
          for (var _i18 = 0; _i18 < _size14; ++_i18)
          {
            var elem19 = null
            elem19 = input.readString()
            this.column_names.push(elem19)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.slice_range = new ttypes.SliceRange()
        this.slice_range.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

SlicePredicate.prototype.write = function(output){ 
  output.writeStructBegin('SlicePredicate')
  if (null != this.column_names) {
    output.writeFieldBegin('column_names', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length)
      {
        for(var iter20 in this.column_names)
        {
          if (this.column_names.hasOwnProperty(iter20))
          {
            iter20=this.column_names[iter20]
            output.writeString(iter20)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.slice_range) {
    output.writeFieldBegin('slice_range', Thrift.Type.STRUCT, 2)
    this.slice_range.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var IndexExpression = module.exports.IndexExpression = function(args){
  this.column_name = null
  this.op = null
  this.value = null
if( args != null ){  if (null != args.column_name)
  this.column_name = args.column_name
  if (null != args.op)
  this.op = args.op
  if (null != args.value)
  this.value = args.value
}}
IndexExpression.prototype = {}
IndexExpression.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.column_name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.op = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

IndexExpression.prototype.write = function(output){ 
  output.writeStructBegin('IndexExpression')
  if (null != this.column_name) {
    output.writeFieldBegin('column_name', Thrift.Type.STRING, 1)
    output.writeString(this.column_name)
    output.writeFieldEnd()
  }
  if (null != this.op) {
    output.writeFieldBegin('op', Thrift.Type.I32, 2)
    output.writeI32(this.op)
    output.writeFieldEnd()
  }
  if (null != this.value) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 3)
    output.writeString(this.value)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var IndexClause = module.exports.IndexClause = function(args){
  this.expressions = null
  this.start_key = null
  this.count = 100
if( args != null ){  if (null != args.expressions)
  this.expressions = args.expressions
  if (null != args.start_key)
  this.start_key = args.start_key
  if (null != args.count)
  this.count = args.count
}}
IndexClause.prototype = {}
IndexClause.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size21 = 0
          var rtmp3
          this.expressions = []
          var _etype24 = 0
          rtmp3 = input.readListBegin()
          _etype24 = rtmp3.etype
          _size21 = rtmp3.size
          for (var _i25 = 0; _i25 < _size21; ++_i25)
          {
            var elem26 = null
            elem26 = new ttypes.IndexExpression()
            elem26.read(input)
            this.expressions.push(elem26)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.start_key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

IndexClause.prototype.write = function(output){ 
  output.writeStructBegin('IndexClause')
  if (null != this.expressions) {
    output.writeFieldBegin('expressions', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.expressions.length)
      {
        for(var iter27 in this.expressions)
        {
          if (this.expressions.hasOwnProperty(iter27))
          {
            iter27=this.expressions[iter27]
            iter27.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.start_key) {
    output.writeFieldBegin('start_key', Thrift.Type.STRING, 2)
    output.writeString(this.start_key)
    output.writeFieldEnd()
  }
  if (null != this.count) {
    output.writeFieldBegin('count', Thrift.Type.I32, 3)
    output.writeI32(this.count)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var KeyRange = module.exports.KeyRange = function(args){
  this.start_key = null
  this.end_key = null
  this.start_token = null
  this.end_token = null
  this.count = 100
if( args != null ){  if (null != args.start_key)
  this.start_key = args.start_key
  if (null != args.end_key)
  this.end_key = args.end_key
  if (null != args.start_token)
  this.start_token = args.start_token
  if (null != args.end_token)
  this.end_token = args.end_token
  if (null != args.count)
  this.count = args.count
}}
KeyRange.prototype = {}
KeyRange.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.start_key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.end_key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 5:      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

KeyRange.prototype.write = function(output){ 
  output.writeStructBegin('KeyRange')
  if (null != this.start_key) {
    output.writeFieldBegin('start_key', Thrift.Type.STRING, 1)
    output.writeString(this.start_key)
    output.writeFieldEnd()
  }
  if (null != this.end_key) {
    output.writeFieldBegin('end_key', Thrift.Type.STRING, 2)
    output.writeString(this.end_key)
    output.writeFieldEnd()
  }
  if (null != this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 3)
    output.writeString(this.start_token)
    output.writeFieldEnd()
  }
  if (null != this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 4)
    output.writeString(this.end_token)
    output.writeFieldEnd()
  }
  if (null != this.count) {
    output.writeFieldBegin('count', Thrift.Type.I32, 5)
    output.writeI32(this.count)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var KeySlice = module.exports.KeySlice = function(args){
  this.key = null
  this.columns = null
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.columns)
  this.columns = args.columns
}}
KeySlice.prototype = {}
KeySlice.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size28 = 0
          var rtmp3
          this.columns = []
          var _etype31 = 0
          rtmp3 = input.readListBegin()
          _etype31 = rtmp3.etype
          _size28 = rtmp3.size
          for (var _i32 = 0; _i32 < _size28; ++_i32)
          {
            var elem33 = null
            elem33 = new ttypes.ColumnOrSuperColumn()
            elem33.read(input)
            this.columns.push(elem33)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

KeySlice.prototype.write = function(output){ 
  output.writeStructBegin('KeySlice')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.columns) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length)
      {
        for(var iter34 in this.columns)
        {
          if (this.columns.hasOwnProperty(iter34))
          {
            iter34=this.columns[iter34]
            iter34.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var KeyCount = module.exports.KeyCount = function(args){
  this.key = null
  this.count = null
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.count)
  this.count = args.count
}}
KeyCount.prototype = {}
KeyCount.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.count = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

KeyCount.prototype.write = function(output){ 
  output.writeStructBegin('KeyCount')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.count) {
    output.writeFieldBegin('count', Thrift.Type.I32, 2)
    output.writeI32(this.count)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Deletion = module.exports.Deletion = function(args){
  this.timestamp = null
  this.super_column = null
  this.predicate = null
if( args != null ){  if (null != args.timestamp)
  this.timestamp = args.timestamp
  if (null != args.super_column)
  this.super_column = args.super_column
  if (null != args.predicate)
  this.predicate = args.predicate
}}
Deletion.prototype = {}
Deletion.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.super_column = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Deletion.prototype.write = function(output){ 
  output.writeStructBegin('Deletion')
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 1)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  if (null != this.super_column) {
    output.writeFieldBegin('super_column', Thrift.Type.STRING, 2)
    output.writeString(this.super_column)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Mutation = module.exports.Mutation = function(args){
  this.column_or_supercolumn = null
  this.deletion = null
if( args != null ){  if (null != args.column_or_supercolumn)
  this.column_or_supercolumn = args.column_or_supercolumn
  if (null != args.deletion)
  this.deletion = args.deletion
}}
Mutation.prototype = {}
Mutation.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_or_supercolumn = new ttypes.ColumnOrSuperColumn()
        this.column_or_supercolumn.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.deletion = new ttypes.Deletion()
        this.deletion.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Mutation.prototype.write = function(output){ 
  output.writeStructBegin('Mutation')
  if (null != this.column_or_supercolumn) {
    output.writeFieldBegin('column_or_supercolumn', Thrift.Type.STRUCT, 1)
    this.column_or_supercolumn.write(output)
    output.writeFieldEnd()
  }
  if (null != this.deletion) {
    output.writeFieldBegin('deletion', Thrift.Type.STRUCT, 2)
    this.deletion.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var TokenRange = module.exports.TokenRange = function(args){
  this.start_token = null
  this.end_token = null
  this.endpoints = null
if( args != null ){  if (null != args.start_token)
  this.start_token = args.start_token
  if (null != args.end_token)
  this.end_token = args.end_token
  if (null != args.endpoints)
  this.endpoints = args.endpoints
}}
TokenRange.prototype = {}
TokenRange.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.LIST) {
        {
          var _size35 = 0
          var rtmp3
          this.endpoints = []
          var _etype38 = 0
          rtmp3 = input.readListBegin()
          _etype38 = rtmp3.etype
          _size35 = rtmp3.size
          for (var _i39 = 0; _i39 < _size35; ++_i39)
          {
            var elem40 = null
            elem40 = input.readString()
            this.endpoints.push(elem40)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

TokenRange.prototype.write = function(output){ 
  output.writeStructBegin('TokenRange')
  if (null != this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 1)
    output.writeString(this.start_token)
    output.writeFieldEnd()
  }
  if (null != this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 2)
    output.writeString(this.end_token)
    output.writeFieldEnd()
  }
  if (null != this.endpoints) {
    output.writeFieldBegin('endpoints', Thrift.Type.LIST, 3)
    {
      output.writeListBegin(Thrift.Type.STRING, this.endpoints.length)
      {
        for(var iter41 in this.endpoints)
        {
          if (this.endpoints.hasOwnProperty(iter41))
          {
            iter41=this.endpoints[iter41]
            output.writeString(iter41)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var AuthenticationRequest = module.exports.AuthenticationRequest = function(args){
  this.credentials = null
if( args != null ){  if (null != args.credentials)
  this.credentials = args.credentials
}}
AuthenticationRequest.prototype = {}
AuthenticationRequest.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.MAP) {
        {
          var _size42 = 0
          var rtmp3
          this.credentials = {}
          var _ktype43 = 0
          var _vtype44 = 0
          rtmp3 = input.readMapBegin()
          _ktype43= rtmp3.ktype
          _vtype44= rtmp3.vtype
          _size42= rtmp3.size
          for (var _i46 = 0; _i46 < _size42; ++_i46)
          {
            key47 = null
            val48 = null
            key47 = input.readString()
            val48 = input.readString()
            this.credentials[key47] = val48
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

AuthenticationRequest.prototype.write = function(output){ 
  output.writeStructBegin('AuthenticationRequest')
  if (null != this.credentials) {
    output.writeFieldBegin('credentials', Thrift.Type.MAP, 1)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.credentials))
      {
        for(var kiter49 in this.credentials)        {
          if (this.credentials.hasOwnProperty(kiter49))
          {
            var viter50 = this.credentials[kiter49]
            output.writeString(kiter49)
            output.writeString(viter50)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var ColumnDef = module.exports.ColumnDef = function(args){
  this.name = null
  this.validation_class = null
  this.index_type = null
  this.index_name = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.validation_class)
  this.validation_class = args.validation_class
  if (null != args.index_type)
  this.index_type = args.index_type
  if (null != args.index_name)
  this.index_name = args.index_name
}}
ColumnDef.prototype = {}
ColumnDef.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.validation_class = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.index_type = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRING) {
        this.index_name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

ColumnDef.prototype.write = function(output){ 
  output.writeStructBegin('ColumnDef')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.validation_class) {
    output.writeFieldBegin('validation_class', Thrift.Type.STRING, 2)
    output.writeString(this.validation_class)
    output.writeFieldEnd()
  }
  if (null != this.index_type) {
    output.writeFieldBegin('index_type', Thrift.Type.I32, 3)
    output.writeI32(this.index_type)
    output.writeFieldEnd()
  }
  if (null != this.index_name) {
    output.writeFieldBegin('index_name', Thrift.Type.STRING, 4)
    output.writeString(this.index_name)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CfDef = module.exports.CfDef = function(args){
  this.keyspace = null
  this.name = null
  this.column_type = 'Standard'
  this.comparator_type = 'BytesType'
  this.subcomparator_type = null
  this.comment = null
  this.row_cache_size = 0
  this.key_cache_size = 200000
  this.read_repair_chance = 1
  this.column_metadata = null
  this.gc_grace_seconds = null
  this.default_validation_class = null
  this.id = null
  this.min_compaction_threshold = null
  this.max_compaction_threshold = null
  this.row_cache_save_period_in_seconds = null
  this.key_cache_save_period_in_seconds = null
  this.memtable_flush_after_mins = null
  this.memtable_throughput_in_mb = null
  this.memtable_operations_in_millions = null
  this.replicate_on_write = null
  this.merge_shards_chance = null
  this.key_validation_class = null
  this.row_cache_provider = 'org.apache.cassandra.cache.ConcurrentLinkedHashCacheProvider'
  this.key_alias = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
  if (null != args.name)
  this.name = args.name
  if (null != args.column_type)
  this.column_type = args.column_type
  if (null != args.comparator_type)
  this.comparator_type = args.comparator_type
  if (null != args.subcomparator_type)
  this.subcomparator_type = args.subcomparator_type
  if (null != args.comment)
  this.comment = args.comment
  if (null != args.row_cache_size)
  this.row_cache_size = args.row_cache_size
  if (null != args.key_cache_size)
  this.key_cache_size = args.key_cache_size
  if (null != args.read_repair_chance)
  this.read_repair_chance = args.read_repair_chance
  if (null != args.column_metadata)
  this.column_metadata = args.column_metadata
  if (null != args.gc_grace_seconds)
  this.gc_grace_seconds = args.gc_grace_seconds
  if (null != args.default_validation_class)
  this.default_validation_class = args.default_validation_class
  if (null != args.id)
  this.id = args.id
  if (null != args.min_compaction_threshold)
  this.min_compaction_threshold = args.min_compaction_threshold
  if (null != args.max_compaction_threshold)
  this.max_compaction_threshold = args.max_compaction_threshold
  if (null != args.row_cache_save_period_in_seconds)
  this.row_cache_save_period_in_seconds = args.row_cache_save_period_in_seconds
  if (null != args.key_cache_save_period_in_seconds)
  this.key_cache_save_period_in_seconds = args.key_cache_save_period_in_seconds
  if (null != args.memtable_flush_after_mins)
  this.memtable_flush_after_mins = args.memtable_flush_after_mins
  if (null != args.memtable_throughput_in_mb)
  this.memtable_throughput_in_mb = args.memtable_throughput_in_mb
  if (null != args.memtable_operations_in_millions)
  this.memtable_operations_in_millions = args.memtable_operations_in_millions
  if (null != args.replicate_on_write)
  this.replicate_on_write = args.replicate_on_write
  if (null != args.merge_shards_chance)
  this.merge_shards_chance = args.merge_shards_chance
  if (null != args.key_validation_class)
  this.key_validation_class = args.key_validation_class
  if (null != args.row_cache_provider)
  this.row_cache_provider = args.row_cache_provider
  if (null != args.key_alias)
  this.key_alias = args.key_alias
}}
CfDef.prototype = {}
CfDef.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.column_type = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 5:      if (ftype == Thrift.Type.STRING) {
        this.comparator_type = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 6:      if (ftype == Thrift.Type.STRING) {
        this.subcomparator_type = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 8:      if (ftype == Thrift.Type.STRING) {
        this.comment = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 9:      if (ftype == Thrift.Type.DOUBLE) {
        this.row_cache_size = input.readDouble()
      } else {
        input.skip(ftype)
      }
      break
      case 11:      if (ftype == Thrift.Type.DOUBLE) {
        this.key_cache_size = input.readDouble()
      } else {
        input.skip(ftype)
      }
      break
      case 12:      if (ftype == Thrift.Type.DOUBLE) {
        this.read_repair_chance = input.readDouble()
      } else {
        input.skip(ftype)
      }
      break
      case 13:      if (ftype == Thrift.Type.LIST) {
        {
          var _size51 = 0
          var rtmp3
          this.column_metadata = []
          var _etype54 = 0
          rtmp3 = input.readListBegin()
          _etype54 = rtmp3.etype
          _size51 = rtmp3.size
          for (var _i55 = 0; _i55 < _size51; ++_i55)
          {
            var elem56 = null
            elem56 = new ttypes.ColumnDef()
            elem56.read(input)
            this.column_metadata.push(elem56)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 14:      if (ftype == Thrift.Type.I32) {
        this.gc_grace_seconds = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 15:      if (ftype == Thrift.Type.STRING) {
        this.default_validation_class = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 16:      if (ftype == Thrift.Type.I32) {
        this.id = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 17:      if (ftype == Thrift.Type.I32) {
        this.min_compaction_threshold = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 18:      if (ftype == Thrift.Type.I32) {
        this.max_compaction_threshold = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 19:      if (ftype == Thrift.Type.I32) {
        this.row_cache_save_period_in_seconds = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 20:      if (ftype == Thrift.Type.I32) {
        this.key_cache_save_period_in_seconds = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 21:      if (ftype == Thrift.Type.I32) {
        this.memtable_flush_after_mins = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 22:      if (ftype == Thrift.Type.I32) {
        this.memtable_throughput_in_mb = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 23:      if (ftype == Thrift.Type.DOUBLE) {
        this.memtable_operations_in_millions = input.readDouble()
      } else {
        input.skip(ftype)
      }
      break
      case 24:      if (ftype == Thrift.Type.BOOL) {
        this.replicate_on_write = input.readBool()
      } else {
        input.skip(ftype)
      }
      break
      case 25:      if (ftype == Thrift.Type.DOUBLE) {
        this.merge_shards_chance = input.readDouble()
      } else {
        input.skip(ftype)
      }
      break
      case 26:      if (ftype == Thrift.Type.STRING) {
        this.key_validation_class = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 27:      if (ftype == Thrift.Type.STRING) {
        this.row_cache_provider = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 28:      if (ftype == Thrift.Type.STRING) {
        this.key_alias = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

CfDef.prototype.write = function(output){ 
  output.writeStructBegin('CfDef')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 2)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.column_type) {
    output.writeFieldBegin('column_type', Thrift.Type.STRING, 3)
    output.writeString(this.column_type)
    output.writeFieldEnd()
  }
  if (null != this.comparator_type) {
    output.writeFieldBegin('comparator_type', Thrift.Type.STRING, 5)
    output.writeString(this.comparator_type)
    output.writeFieldEnd()
  }
  if (null != this.subcomparator_type) {
    output.writeFieldBegin('subcomparator_type', Thrift.Type.STRING, 6)
    output.writeString(this.subcomparator_type)
    output.writeFieldEnd()
  }
  if (null != this.comment) {
    output.writeFieldBegin('comment', Thrift.Type.STRING, 8)
    output.writeString(this.comment)
    output.writeFieldEnd()
  }
  if (null != this.row_cache_size) {
    output.writeFieldBegin('row_cache_size', Thrift.Type.DOUBLE, 9)
    output.writeDouble(this.row_cache_size)
    output.writeFieldEnd()
  }
  if (null != this.key_cache_size) {
    output.writeFieldBegin('key_cache_size', Thrift.Type.DOUBLE, 11)
    output.writeDouble(this.key_cache_size)
    output.writeFieldEnd()
  }
  if (null != this.read_repair_chance) {
    output.writeFieldBegin('read_repair_chance', Thrift.Type.DOUBLE, 12)
    output.writeDouble(this.read_repair_chance)
    output.writeFieldEnd()
  }
  if (null != this.column_metadata) {
    output.writeFieldBegin('column_metadata', Thrift.Type.LIST, 13)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.column_metadata.length)
      {
        for(var iter57 in this.column_metadata)
        {
          if (this.column_metadata.hasOwnProperty(iter57))
          {
            iter57=this.column_metadata[iter57]
            iter57.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.gc_grace_seconds) {
    output.writeFieldBegin('gc_grace_seconds', Thrift.Type.I32, 14)
    output.writeI32(this.gc_grace_seconds)
    output.writeFieldEnd()
  }
  if (null != this.default_validation_class) {
    output.writeFieldBegin('default_validation_class', Thrift.Type.STRING, 15)
    output.writeString(this.default_validation_class)
    output.writeFieldEnd()
  }
  if (null != this.id) {
    output.writeFieldBegin('id', Thrift.Type.I32, 16)
    output.writeI32(this.id)
    output.writeFieldEnd()
  }
  if (null != this.min_compaction_threshold) {
    output.writeFieldBegin('min_compaction_threshold', Thrift.Type.I32, 17)
    output.writeI32(this.min_compaction_threshold)
    output.writeFieldEnd()
  }
  if (null != this.max_compaction_threshold) {
    output.writeFieldBegin('max_compaction_threshold', Thrift.Type.I32, 18)
    output.writeI32(this.max_compaction_threshold)
    output.writeFieldEnd()
  }
  if (null != this.row_cache_save_period_in_seconds) {
    output.writeFieldBegin('row_cache_save_period_in_seconds', Thrift.Type.I32, 19)
    output.writeI32(this.row_cache_save_period_in_seconds)
    output.writeFieldEnd()
  }
  if (null != this.key_cache_save_period_in_seconds) {
    output.writeFieldBegin('key_cache_save_period_in_seconds', Thrift.Type.I32, 20)
    output.writeI32(this.key_cache_save_period_in_seconds)
    output.writeFieldEnd()
  }
  if (null != this.memtable_flush_after_mins) {
    output.writeFieldBegin('memtable_flush_after_mins', Thrift.Type.I32, 21)
    output.writeI32(this.memtable_flush_after_mins)
    output.writeFieldEnd()
  }
  if (null != this.memtable_throughput_in_mb) {
    output.writeFieldBegin('memtable_throughput_in_mb', Thrift.Type.I32, 22)
    output.writeI32(this.memtable_throughput_in_mb)
    output.writeFieldEnd()
  }
  if (null != this.memtable_operations_in_millions) {
    output.writeFieldBegin('memtable_operations_in_millions', Thrift.Type.DOUBLE, 23)
    output.writeDouble(this.memtable_operations_in_millions)
    output.writeFieldEnd()
  }
  if (null != this.replicate_on_write) {
    output.writeFieldBegin('replicate_on_write', Thrift.Type.BOOL, 24)
    output.writeBool(this.replicate_on_write)
    output.writeFieldEnd()
  }
  if (null != this.merge_shards_chance) {
    output.writeFieldBegin('merge_shards_chance', Thrift.Type.DOUBLE, 25)
    output.writeDouble(this.merge_shards_chance)
    output.writeFieldEnd()
  }
  if (null != this.key_validation_class) {
    output.writeFieldBegin('key_validation_class', Thrift.Type.STRING, 26)
    output.writeString(this.key_validation_class)
    output.writeFieldEnd()
  }
  if (null != this.row_cache_provider) {
    output.writeFieldBegin('row_cache_provider', Thrift.Type.STRING, 27)
    output.writeString(this.row_cache_provider)
    output.writeFieldEnd()
  }
  if (null != this.key_alias) {
    output.writeFieldBegin('key_alias', Thrift.Type.STRING, 28)
    output.writeString(this.key_alias)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var KsDef = module.exports.KsDef = function(args){
  this.name = null
  this.strategy_class = null
  this.strategy_options = null
  this.cf_defs = null
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.strategy_class)
  this.strategy_class = args.strategy_class
  if (null != args.strategy_options)
  this.strategy_options = args.strategy_options
  if (null != args.cf_defs)
  this.cf_defs = args.cf_defs
}}
KsDef.prototype = {}
KsDef.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.strategy_class = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.MAP) {
        {
          var _size58 = 0
          var rtmp3
          this.strategy_options = {}
          var _ktype59 = 0
          var _vtype60 = 0
          rtmp3 = input.readMapBegin()
          _ktype59= rtmp3.ktype
          _vtype60= rtmp3.vtype
          _size58= rtmp3.size
          for (var _i62 = 0; _i62 < _size58; ++_i62)
          {
            key63 = null
            val64 = null
            key63 = input.readString()
            val64 = input.readString()
            this.strategy_options[key63] = val64
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.LIST) {
        {
          var _size65 = 0
          var rtmp3
          this.cf_defs = []
          var _etype68 = 0
          rtmp3 = input.readListBegin()
          _etype68 = rtmp3.etype
          _size65 = rtmp3.size
          for (var _i69 = 0; _i69 < _size65; ++_i69)
          {
            var elem70 = null
            elem70 = new ttypes.CfDef()
            elem70.read(input)
            this.cf_defs.push(elem70)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

KsDef.prototype.write = function(output){ 
  output.writeStructBegin('KsDef')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.strategy_class) {
    output.writeFieldBegin('strategy_class', Thrift.Type.STRING, 2)
    output.writeString(this.strategy_class)
    output.writeFieldEnd()
  }
  if (null != this.strategy_options) {
    output.writeFieldBegin('strategy_options', Thrift.Type.MAP, 3)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.strategy_options))
      {
        for(var kiter71 in this.strategy_options)        {
          if (this.strategy_options.hasOwnProperty(kiter71))
          {
            var viter72 = this.strategy_options[kiter71]
            output.writeString(kiter71)
            output.writeString(viter72)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.cf_defs) {
    output.writeFieldBegin('cf_defs', Thrift.Type.LIST, 4)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.cf_defs.length)
      {
        for(var iter73 in this.cf_defs)
        {
          if (this.cf_defs.hasOwnProperty(iter73))
          {
            iter73=this.cf_defs[iter73]
            iter73.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CqlRow = module.exports.CqlRow = function(args){
  this.key = null
  this.columns = null
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.columns)
  this.columns = args.columns
}}
CqlRow.prototype = {}
CqlRow.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size74 = 0
          var rtmp3
          this.columns = []
          var _etype77 = 0
          rtmp3 = input.readListBegin()
          _etype77 = rtmp3.etype
          _size74 = rtmp3.size
          for (var _i78 = 0; _i78 < _size74; ++_i78)
          {
            var elem79 = null
            elem79 = new ttypes.Column()
            elem79.read(input)
            this.columns.push(elem79)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

CqlRow.prototype.write = function(output){ 
  output.writeStructBegin('CqlRow')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.columns) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length)
      {
        for(var iter80 in this.columns)
        {
          if (this.columns.hasOwnProperty(iter80))
          {
            iter80=this.columns[iter80]
            iter80.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CqlResult = module.exports.CqlResult = function(args){
  this.type = null
  this.rows = null
  this.num = null
if( args != null ){  if (null != args.type)
  this.type = args.type
  if (null != args.rows)
  this.rows = args.rows
  if (null != args.num)
  this.num = args.num
}}
CqlResult.prototype = {}
CqlResult.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size81 = 0
          var rtmp3
          this.rows = []
          var _etype84 = 0
          rtmp3 = input.readListBegin()
          _etype84 = rtmp3.etype
          _size81 = rtmp3.size
          for (var _i85 = 0; _i85 < _size81; ++_i85)
          {
            var elem86 = null
            elem86 = new ttypes.CqlRow()
            elem86.read(input)
            this.rows.push(elem86)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.num = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

CqlResult.prototype.write = function(output){ 
  output.writeStructBegin('CqlResult')
  if (null != this.type) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1)
    output.writeI32(this.type)
    output.writeFieldEnd()
  }
  if (null != this.rows) {
    output.writeFieldBegin('rows', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length)
      {
        for(var iter87 in this.rows)
        {
          if (this.rows.hasOwnProperty(iter87))
          {
            iter87=this.rows[iter87]
            iter87.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.num) {
    output.writeFieldBegin('num', Thrift.Type.I32, 3)
    output.writeI32(this.num)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

